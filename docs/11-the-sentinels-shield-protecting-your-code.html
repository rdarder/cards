<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>The Sentinel’s Shield (Protecting Your Code) 🛡️</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<h1 data-number="11"
id="the-sentinels-shield-protecting-your-code"><span
class="header-section-number">11</span> The Sentinel’s Shield
(Protecting Your Code) 🛡️</h1>
<hr />
<h2 data-number="11.1" id="the-story-so-far-8"><span
class="header-section-number">11.1</span> The Story So Far…</h2>
<p>You’ve built a truly complex and exciting “Grand Melee”! But with
this complexity comes a new danger. If you change one part of the code,
how can you be sure you didn’t accidentally break something else?
Checking everything by hand after every change is slow and impossible.
It’s time to build a sentinel—an automated guard for your code.</p>
<h2 data-number="11.2"
id="the-mission-what-well-accomplish-today-9"><span
class="header-section-number">11.2</span> The Mission: What We’ll
Accomplish Today</h2>
<p>Our mission is to pause on adding new game features and instead build
a “test suite”—a separate script that automatically runs simulations and
checks if our game logic behaves exactly as we promise it will. To do
this, we’ll first learn how to properly organize our code into
“libraries” and “scripts.”</p>
<h2 data-number="11.3" id="the-spellbook-the-art-of-guardianship"><span
class="header-section-number">11.3</span> The Spellbook: The Art of
Guardianship</h2>
<p><strong>1. Libraries vs. Scripts (The Spellbook vs. The
Incantation)</strong></p>
<p>This is the most important organizational idea in programming. Not
all <code>.lua</code> files are the same.</p>
<p><strong>Analogy:</strong> A <strong>library</strong> is like a
<strong>spellbook</strong>. It’s a collection of powerful spells
(functions) and definitions (data). Sitting on the shelf, a spellbook
doesn’t <em>do</em> anything. Its job is to simply be a source of
knowledge. A <strong>script</strong> is like an
<strong>incantation</strong> or a ritual. It’s a sequence of actions
that <em>uses</em> the spellbook (<code>require</code>) to actually make
something happen.</p>
<ul>
<li><strong>Libraries (<code>game_logic.lua</code>,
<code>cards.lua</code>):</strong> These files should only contain
definitions. They define functions and data and, at the very end,
<code>return</code> a table containing those tools. A library file
should <strong>never</strong> run the game or print things on its
own.</li>
<li><strong>Scripts (<code>main.lua</code>,
<code>tests.lua</code>):</strong> These are the “do-ers.” Their job is
to <code>require</code> the libraries and then call the functions to
perform a task, whether it’s playing the game or testing it.</li>
</ul>
<p>By separating our code this way, we can <code>require</code> our
<code>game_logic.lua</code> spellbook in our test file without worrying
about the whole game starting up unexpectedly.</p>
<p><strong>2. The “Why” of Testing: A Promise to the Future</strong></p>
<p>An automated test is a <strong>contract</strong> or a
<strong>promise</strong> you make about your code. When you test your
<code>attack</code> function, you are promising: “I guarantee this
function will always reduce the target’s life by the correct amount.”
This protects your future self from breaking your game’s most important
rules.</p>
<p><strong>3. What Should We Test? Protecting the Crown
Jewels</strong></p>
<p>Deciding <em>what</em> to test is a conscious effort. We focus on the
“crown jewels”: the core, stable rules of our game. The
<code>attack</code> logic is a perfect example. It’s a fundamental rule
that many future features will depend on. We test it to ensure we’re
building on a solid foundation.</p>
<p><strong>4. <code>assert()</code> (The Sentinel’s Alarm)</strong></p>
<p>This is our simple tool for checking promises.
<code>assert(condition, "message")</code> is a silent guardian.</p>
<ul>
<li>If the <code>condition</code> is <code>true</code>, it does
nothing.</li>
<li>If the <code>condition</code> is <code>false</code>, it stops the
program and shouts the error <code>message</code>.</li>
</ul>
<h2 data-number="11.4" id="your-quest-forging-the-shield"><span
class="header-section-number">11.4</span> Your Quest: Forging the
Shield</h2>
<p><strong>Quest A: The Single-Strike Test</strong> Let’s start by
testing our most important “crown jewel.”</p>
<ol type="1">
<li><strong>Refactor into a Library:</strong> Make sure your
<code>game_logic.lua</code> file is a proper library. It should define
the <code>attack</code> function and <code>return</code> it in a table.
It should not run any game logic itself.</li>
<li><strong>Create the Test Script:</strong> Create a new file,
<code>tests.lua</code>.</li>
<li><strong>Setup:</strong> In <code>tests.lua</code>,
<code>require</code> your <code>game_logic.lua</code> library.</li>
<li><strong>Craft the Actors:</strong> Create two simple, predictable
card tables by hand.
<code>lua     local knight = { name = "Test Knight", attack = 7, life = 20 }     local goblin = { name = "Test Goblin", attack = 3, life = 10 }</code></li>
<li><strong>Execute and Assert:</strong> Call the function and assert
the promise about the outcome.
<code>game_logic.attack(knight, goblin)</code>
<code>assert(goblin.life == 3, "Single-strike test failed: Goblin's final health was not 3!")</code></li>
<li><strong>Run the Test:</strong> Run <code>lua tests.lua</code>. If it
passes silently, the first part of your shield is in place.</li>
</ol>
<p><strong>Quest B: The Full Melee Simulation</strong> Now for the
bigger test. To test the entire round, we need to make sure that logic
also lives in our library.</p>
<ol type="1">
<li><strong>The Refactor:</strong> Create a new function in your
<code>game_logic.lua</code> library called
<code>run_round(player_cards, computer_cards)</code>.
<strong>Cut</strong> the entire Grand Melee logic from
<code>main.lua</code> and <strong>paste</strong> it into this new
function. The function should <code>return</code> the final state of the
two hands. Your <code>main.lua</code> should now be a pure
<strong>script</strong>—it just requires libraries, generates random
hands, and then calls <code>game_logic.run_round()</code>.</li>
<li><strong>Craft the Battlefield:</strong> Back in
<code>tests.lua</code>, create two full, hand-crafted 3-card hands
designed to have a predictable outcome.</li>
<li><strong>Execute the Simulation:</strong> Call your new round
function:
<code>local final_player_hand, final_computer_hand = game_logic.run_round(test_player_hand, test_computer_hand)</code>.</li>
<li><strong>Assert the Final State:</strong> Make a series of promises
about what the battlefield should look like after the dust settles.
<code>lua     print("Running full melee simulation test...")     assert(final_player_hand[1].life == 12, "Player Card 1 failed health check.")     assert(final_computer_hand[2].life &lt;= 0, "Computer Card 2 should have been defeated.")     print("Full melee simulation passed!")</code></li>
</ol>
<h2 data-number="11.5" id="the-payoff"><span
class="header-section-number">11.5</span> The Payoff</h2>
<p>By building this sentinel’s shield and organizing your code into
libraries and scripts, you’ve adopted two of the most professional
habits in programming. You can now change your game with confidence,
knowing your sentinel will instantly warn you if you break one of your
core promises.</p>
<nav id="sitenav">
<div class="sitenav">
<span class="navlink next">
</span>
<span class="navlink">
</span>
</div>
<div class="sitenav">
<span class="navlink top">
<a href="index.html" accesskey="t" rel="top">Code &amp; Sorcery: A Lua Card Game Quest</a>
</span>
</div>
</nav>
</body>
</html>
