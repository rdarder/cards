<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>The Grand Melee 💥</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<h1 data-number="9" id="the-grand-melee"><span
class="header-section-number">9</span> The Grand Melee 💥</h1>
<hr />
<h2 data-number="9.1" id="the-story-so-far-6"><span
class="header-section-number">9.1</span> The Story So Far…</h2>
<p>You created an epic “First Clash” in the last unit! It was the first
time your game felt truly interactive. But that single attack was just
the opening move. A real battle is a chaotic melee where every creature
gets a turn. As we’ll see, making this happen introduces some tricky new
challenges that will require some clever new tactics to solve.</p>
<h2 data-number="9.2"
id="the-mission-what-well-accomplish-today-7"><span
class="header-section-number">9.2</span> The Mission: What We’ll
Accomplish Today</h2>
<p>Our mission is to implement a full battle round where all 6 cards on
the table get to act. The program will: 1. Create two 3-card hands for
the player and computer. 2. Intelligently determine the correct turn
order, one turn at a time. 3. Allow each living card to attack a living
opponent. 4. Print the final status of all cards after the battle is
over.</p>
<hr />
<h2 data-number="9.3" id="the-new-challenge-who-attacks-next"><span
class="header-section-number">9.3</span> 1. The New Challenge: Who
Attacks Next?</h2>
<p>Our old “find the single fastest card” logic is broken now. Why?
Because in a full round: 1. A card that is defeated before its turn
can’t attack at all. 2. Once a card takes its turn, it can’t attack
again in the same round.</p>
<p>Simply finding the fastest card over and over won’t work. We might
pick the same card twice, or pick a card that’s already been defeated.
We need a smarter way to track the state of the whole battlefield.</p>
<h3 data-number="9.3.1" id="our-new-tactic-the-battlefield-list"><span
class="header-section-number">9.3.1</span> Our New Tactic: The
Battlefield List</h3>
<p>To solve this, we’ll create <strong>one single list</strong> of all 6
cards on the battlefield. To avoid losing track of who owns each card,
our list will hold small “turn marker” tables.</p>
<p>It’s worth noting that this tactic isn’t exactly how a human would do
it. You’d just look at the table and intuitively know who’s left and who
is fastest. But a computer doesn’t have intuition; it has a very narrow
focus. We need to give it a very precise recipe (an
<strong>algorithm</strong>) to follow so that it never misses a card or
makes the wrong choice. This list is the first step in that recipe.</p>
<p>The structure for each item in our new list will be a table like
this:
<code>{ card = { ... }, owner = "player", has_attacked = false }</code></p>
<p>The <code>has_attacked = false</code> is a new
<strong>boolean</strong> flag—our “light switch” for tracking who has
already had their turn this round.</p>
<hr />
<h2 data-number="9.4"
id="the-targeting-problem-who-can-be-attacked"><span
class="header-section-number">9.4</span> 2. The Targeting Problem: Who
Can Be Attacked?</h2>
<p>The second big challenge is that an attacker can’t target a card that
has already been defeated. The opponent’s hand might have 3 card slots,
but only one or two might be valid, living targets.</p>
<h3 data-number="9.4.1"
id="our-new-tactic-filtering-for-valid-targets"><span
class="header-section-number">9.4.1</span> Our New Tactic: Filtering for
Valid Targets</h3>
<p>This is the perfect place to use a technique called
<strong>filtering</strong>. Filtering is the simple idea of building a
new, temporary list from an old one, but only including the items that
match a specific rule.</p>
<p>We’ll look at the opponent’s entire hand of 3 cards and build a
<em>new, shorter list</em> that contains only the cards that are still
standing (their <code>life</code> is greater than 0). This new list
becomes our list of valid targets for that specific turn.</p>
<p>Remember our “list of shortcuts” concept: this new
<code>valid_targets</code> list doesn’t contain <em>copies</em> of the
cards; it contains shortcuts to the originals. Damaging a card from this
new list will damage the card in the opponent’s actual hand.</p>
<hr />
<h2 data-number="9.5" id="your-quest-the-grand-melee"><span
class="header-section-number">9.5</span> Your Quest: The Grand
Melee</h2>
<p><strong>Step 1: Setup</strong> 1. Generate the
<code>player_hand</code> and <code>computer_hand</code> with 3 random
cards each. 2. Display the starting cards so the player knows the
battlefield.</p>
<p><strong>Step 2: Create the Battlefield List</strong> 1. Create an
empty table: <code>local battlefield = {}</code>. 2. Use a
<code>for</code> loop to go through the <code>player_hand</code>. For
each card, <code>table.insert</code> a new table
<code>{ card = the_card, owner = "player", has_attacked = false }</code>
into your <code>battlefield</code> list. 3. Do the same for the
<code>computer_hand</code>, using <code>owner = "computer"</code>.</p>
<p><strong>Step 3: The Main Loop</strong> We need a loop that will run
for each of the 6 “turn slots” in the round. A simple numeric
<code>for</code> loop is perfect for this.
<code>for turn_number = 1, 6 do ... end</code></p>
<p><strong>Inside the Loop (For Each Turn):</strong></p>
<p><strong>A. Find the Next Attacker</strong> * This is our core
algorithm for the turn. We need to search the entire
<code>battlefield</code> to find the best possible attacker right now. *
Create two variables before the search:
<code>local next_attacker_info = nil</code> and
<code>local highest_speed = -1</code>. * Now, loop through the
<code>battlefield</code> list
(<code>for i, info in ipairs(battlefield) do...</code>). Inside this
search loop, use an <code>if</code> statement with three conditions:
<code>if info.card.life &gt; 0 and info.has_attacked == false and info.card.speed &gt; highest_speed then ...</code>
* If all three are true, you’ve found a new best attacker for this turn!
Update your variables: <code>highest_speed = info.card.speed</code> and
<code>next_attacker_info = info</code>. * After this search loop
finishes, <code>next_attacker_info</code> will hold the correct card to
attack this turn.</p>
<p><strong>B. The Attack Sequence (If an attacker was found)</strong> *
Use an <code>if</code> statement to check if an attacker was actually
found: <code>if next_attacker_info then ... end</code>. *
<strong>Determine Targets:</strong> Figure out which hand is the
enemy’s. * <strong>Filter Targets:</strong> Build the
<code>valid_targets</code> list by looping through the opponent’s hand
and grabbing only the living cards. * <strong>Perform the
Attack:</strong> Check if there are any valid targets. If so, let the
player or computer choose a target and perform the attack calculation. *
<strong>Update State:</strong> This is critical! After the attack, mark
the attacker’s turn as complete so they can’t be chosen again:
<code>next_attacker_info.has_attacked = true</code>.</p>
<p><strong>Step 4: The Aftermath</strong> 1. After the main
<code>for turn_number = 1, 6 do</code> loop is finished, print a “—
Round Over —” message. 2. Loop through the original
<code>player_hand</code> and <code>computer_hand</code> and display the
final status of all 6 cards.</p>
<h2 data-number="9.6" id="the-troubleshooting-scroll-5"><span
class="header-section-number">9.6</span> The Troubleshooting Scroll</h2>
<ul>
<li><strong>The same card attacks over and over!</strong>
<ul>
<li><strong>Check:</strong> You are likely forgetting to update the
attacker’s state after they attack. Make sure the line
<code>next_attacker_info.has_attacked = true</code> is running
correctly.</li>
</ul></li>
<li><strong>The program crashes trying to attack.</strong>
<ul>
<li><strong>Check:</strong> Are you checking if there are any
<code>valid_targets</code> before trying to attack? If all opponents are
defeated, your <code>valid_targets</code> list will be empty, and trying
to pick a target (<code>valid_targets[1]</code>) will result in
<code>nil</code>. Make sure your attack logic is inside an
<code>if #valid_targets &gt; 0 then ...</code> block.</li>
</ul></li>
</ul>
<nav id="sitenav">
<div class="sitenav">
<span class="navlink next">
<span class="navlink-label">Next Up:</span> <a href="10-the-archetype-the-summoning-spell.html" accesskey="n" rel="next">The Archetype &amp; The Summoning Spell</a>
</span>
<span class="navlink">
</span>
</div>
<div class="sitenav">
<span class="navlink top">
<a href="index.html" accesskey="t" rel="top">Code &amp; Sorcery: A Lua Card Game Quest</a>
</span>
</div>
</nav>
</body>
</html>
